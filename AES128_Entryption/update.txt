module AES128(
    input clk,
    input reset,
    
    // input [31:0] IN_DATA0,//明文
    // input [31:0] IN_DATA1,
    // input [31:0] IN_DATA2, 
    // input [31:0] IN_DATA3,
    input [127:0] IN_DATA,
    // input [31:0] IN_KEY0,//密钥
    // input [31:0] IN_KEY1,
    // input [31:0] IN_KEY2,
    // input [31:0] IN_KEY3,
    input [127:0] IN_KEY,
    // output [31:0] OUT_DATA0, //密文 
    // output [31:0] OUT_DATA1,
    // output [31:0] OUT_DATA2,
    // output [31:0] OUT_DATA3
    output [127:0] OUT_DATA
);
// wire [127:0] IN_DATA, IN_KEY, OUT_DATA;

// assign IN_DATA = {IN_DATA3, IN_DATA2, IN_DATA1, IN_DATA0};
// assign IN_KEY = {IN_KEY3, IN_KEY2, IN_KEY1, IN_KEY0};
// assign {OUT_DATA3, OUT_DATA2, OUT_DATA1, OUT_DATA0} = OUT_DATA;

reg [127:0] R0_OUT_DATA, KEY;
// wire [127:0] R1_OUT_DATA, R2_OUT_DATA, R3_OUT_DATA, R4_OUT_DATA, R5_OUT_DATA, R6_OUT_DATA, R7_OUT_DATA, R8_OUT_DATA, R9_OUT_DATA;
wire [127:0] R_OUT_DATA[0:9];

wire [127:0] OUT_KEYW1, OUT_KEYW2, OUT_KEYW3, OUT_KEYW4, OUT_KEYW5, OUT_KEYW6, OUT_KEYW7, OUT_KEYW8, OUT_KEYW9;
// wire [127:0] OUT_KEYR0, OUT_KEYR1, OUT_KEYR2, OUT_KEYR3, OUT_KEYR4, OUT_KEYR5, OUT_KEYR6, OUT_KEYR7, OUT_KEYR8, OUT_KEYR9;//轮密钥
wire [127:0] OUT_KEYR[0:9];

always @(posedge clk) begin//初始轮钥密加
    // R0_OUT_DATA <= IN_DATA ^ IN_KEY;
    R0_OUT_DATA<=IN_DATA^IN_KEY;
    KEY <= IN_KEY;
end
assign R_OUT_DATA[0]=R0_OUT_DATA;

GENERATE_KEY
        K1 (.clk(clk), .ROUND_KEY(4'd0), .IN_KEY(KEY),       .OUT_KEY(OUT_KEYW1), .OUT_KEY_R(OUT_KEYR[0])),
        K2 (.clk(clk), .ROUND_KEY(4'd1), .IN_KEY(OUT_KEYW1), .OUT_KEY(OUT_KEYW2), .OUT_KEY_R(OUT_KEYR[1])),
        K3 (.clk(clk), .ROUND_KEY(4'd2), .IN_KEY(OUT_KEYW2), .OUT_KEY(OUT_KEYW3), .OUT_KEY_R(OUT_KEYR[2])),
        K4 (.clk(clk), .ROUND_KEY(4'd3), .IN_KEY(OUT_KEYW3), .OUT_KEY(OUT_KEYW4), .OUT_KEY_R(OUT_KEYR[3])),
        K5 (.clk(clk), .ROUND_KEY(4'd4), .IN_KEY(OUT_KEYW4), .OUT_KEY(OUT_KEYW5), .OUT_KEY_R(OUT_KEYR[4])),
        K6 (.clk(clk), .ROUND_KEY(4'd5), .IN_KEY(OUT_KEYW5), .OUT_KEY(OUT_KEYW6), .OUT_KEY_R(OUT_KEYR[5])),
        K7 (.clk(clk), .ROUND_KEY(4'd6), .IN_KEY(OUT_KEYW6), .OUT_KEY(OUT_KEYW7), .OUT_KEY_R(OUT_KEYR[6])),
        K8 (.clk(clk), .ROUND_KEY(4'd7), .IN_KEY(OUT_KEYW7), .OUT_KEY(OUT_KEYW8), .OUT_KEY_R(OUT_KEYR[7])),
        K9 (.clk(clk), .ROUND_KEY(4'd8), .IN_KEY(OUT_KEYW8), .OUT_KEY(OUT_KEYW9), .OUT_KEY_R(OUT_KEYR[8])),
        K10(.clk(clk), .ROUND_KEY(4'd9), .IN_KEY(OUT_KEYW9), .OUT_KEY() ,         .OUT_KEY_R(OUT_KEYR[9]));

genvar i;
generate
    for (i=0; i<9; i=i+1) begin:R
        ROUND_ITERATION R_inst(
            .clk(clk),
            .IN_DATA(R_OUT_DATA[i]),
            .IN_KEY(OUT_KEYR[i]),
            .OUT_DATA(R_OUT_DATA[i+1])
        );
    end
endgenerate


// ROUND_ITERATION R1(.clk(clk), 
//                     .IN_DATA(R0_OUT_DATA), 
//                     .IN_KEY(OUT_KEYR0),
//                     .OUT_DATA(R1_OUT_DATA));

// ROUND_ITERATION R2(.clk(clk), 
//                     .IN_DATA(R1_OUT_DATA),
//                     .IN_KEY(OUT_KEYR1),
//                     .OUT_DATA(R2_OUT_DATA));

// ROUND_ITERATION R3(.clk(clk), 
//                     .IN_DATA(R2_OUT_DATA),
//                     .IN_KEY(OUT_KEYR2),
//                     .OUT_DATA(R3_OUT_DATA));

// ROUND_ITERATION R4(.clk(clk), 
//                     .IN_DATA(R3_OUT_DATA),
//                     .IN_KEY(OUT_KEYR3),
//                     .OUT_DATA(R4_OUT_DATA));

// ROUND_ITERATION R5(.clk(clk), 
//                     .IN_DATA(R4_OUT_DATA),
//                     .IN_KEY(OUT_KEYR4),
//                     .OUT_DATA(R5_OUT_DATA));

// ROUND_ITERATION R6(.clk(clk), 
//                     .IN_DATA(R5_OUT_DATA),
//                     .IN_KEY(OUT_KEYR5),
//                     .OUT_DATA(R6_OUT_DATA));

// ROUND_ITERATION R7(.clk(clk), 
//                     .IN_DATA(R6_OUT_DATA),
//                     .IN_KEY(OUT_KEYR6),
//                     .OUT_DATA(R7_OUT_DATA));

// ROUND_ITERATION R8(.clk(clk), 
//                     .IN_DATA(R7_OUT_DATA),
//                     .IN_KEY(OUT_KEYR7),
//                     .OUT_DATA(R8_OUT_DATA));

// ROUND_ITERATION R9(.clk(clk), 
//                     .IN_DATA(R8_OUT_DATA),
//                     .IN_KEY(OUT_KEYR8),
//                     .OUT_DATA(R9_OUT_DATA));

LAST_ROUND R10(.clk(clk), 
                .IN_DATA(R_OUT_DATA[9]),
                .IN_KEY(OUT_KEYR[9]),
                .OUT_DATA(OUT_DATA));


endmodule


 `timescale 1ns / 1ps

//  `include "aes_top.v"
//  `include "generate_key.v"
//  `include "mix_columns.v"
//  `include "last_round.v"
//  `include "s_box.v"
//  `include "round_iteration.v"
//  `include "shift_rows.v"
//  `include "sub_bytes.v"

module testbench;
  reg clk;
  reg reset;

  // reg [31:0] inp_data_0;
  // reg [31:0] inp_data_1;
  // reg [31:0] inp_data_2;
  // reg [31:0] inp_data_3;
  reg [127:0] inp_data;
  // reg [31:0] inp_key_0;
  // reg [31:0] inp_key_1;
  // reg [31:0] inp_key_2;
  // reg [31:0] inp_key_3;
  reg [127:0] inp_key;
  // wire [31:0] out_data_0;
  // wire [31:0] out_data_1;
  // wire [31:0] out_data_2;
  // wire [31:0] out_data_3;

  // wire [127:0] inp_data;
  // wire [127:0] inp_key;
  wire [127:0] out_data;

  // AES128 AES128_DUT(clk,reset,inp_data_0,inp_data_1,inp_data_2,inp_data_3,inp_key_0,inp_key_1,inp_key_2,inp_key_3,out_data_0,out_data_1,out_data_2,out_data_3);
  AES128 AES128_DUT(clk,reset,inp_data,inp_key,out_data);
  initial 
    begin  
      clk = 0;
      reset = 0;

      // {inp_key_3,inp_key_2,inp_key_1,inp_key_0} = 128'h000102030405060708090a0b0c0d0e0f;
      // {inp_data_3,inp_data_2,inp_data_1,inp_data_0} = 128'h4142434445464748494a4b4c4d4e4f54;
      inp_key = 128'h000102030405060708090a0b0c0d0e0f;
      inp_data = 128'h4142434445464748494a4b4c4d4e4f54;
      // #300 $display("Encrypted value: %h",{out_data_3,out_data_2,out_data_1,out_data_0});
        #300 $display("Encrypted value: %h",out_data);
      #100 $finish;
  end
  // assign out_data = {out_data_3,out_data_2,out_data_1,out_data_0};
  always #5  clk =  ! clk; 
endmodule

module SUB_BYTES(//字节代换，用到S盒的模块，替换16个字节
    input clk,
    input [127:0] IN_DATA,
    output reg [127:0] SB_DATA
);

wire [127:0] SB_DATA_W;

genvar i;
generate
    for (i=0; i<16;i=i+1)begin:INST
        FORWARD_SUBSTITUTION_BOX TEST(
            .clk(clk),
            .A(IN_DATA[i*8+:8]),
            .C(SB_DATA_W[i*8+:8])
        );
        
    end
endgenerate
    // FORWARD_SUBSTITUTION_BOX INST0(.clk(clk), .A(IN_DATA[127:120]), .C(SB_DATA_W[127:120]));
    // FORWARD_SUBSTITUTION_BOX INST1(.clk(clk), .A(IN_DATA[119:112]), .C(SB_DATA_W[119:112]));
    // FORWARD_SUBSTITUTION_BOX INST2(.clk(clk), .A(IN_DATA[111:104]), .C(SB_DATA_W[111:104]));
    // FORWARD_SUBSTITUTION_BOX INST3(.clk(clk), .A(IN_DATA[103:96]), .C(SB_DATA_W[103:96]));
    
    // FORWARD_SUBSTITUTION_BOX INST4(.clk(clk), .A(IN_DATA[95:88]), .C(SB_DATA_W[95:88]));
    // FORWARD_SUBSTITUTION_BOX INST5(.clk(clk), .A(IN_DATA[87:80]), .C(SB_DATA_W[87:80]));
    // FORWARD_SUBSTITUTION_BOX INST6(.clk(clk), .A(IN_DATA[79:72]), .C(SB_DATA_W[79:72]));
    // FORWARD_SUBSTITUTION_BOX INST7(.clk(clk), .A(IN_DATA[71:64]), .C(SB_DATA_W[71:64]));

    // FORWARD_SUBSTITUTION_BOX INST8(.clk(clk), .A(IN_DATA[63:56]), .C(SB_DATA_W[63:56]));
    // FORWARD_SUBSTITUTION_BOX INST9(.clk(clk), .A(IN_DATA[55:48]), .C(SB_DATA_W[55:48]));
    // FORWARD_SUBSTITUTION_BOX INST10(.clk(clk), .A(IN_DATA[47:40]), .C(SB_DATA_W[47:40]));
    // FORWARD_SUBSTITUTION_BOX INST11(.clk(clk), .A(IN_DATA[39:32]), .C(SB_DATA_W[39:32]));
    
    // FORWARD_SUBSTITUTION_BOX INST12(.clk(clk), .A(IN_DATA[31:24]), .C(SB_DATA_W[31:24]));
    // FORWARD_SUBSTITUTION_BOX INST13(.clk(clk), .A(IN_DATA[23:16]), .C(SB_DATA_W[23:16]));
    // FORWARD_SUBSTITUTION_BOX INST14(.clk(clk), .A(IN_DATA[15:8]), .C(SB_DATA_W[15:8]));
    // FORWARD_SUBSTITUTION_BOX INST15(.clk(clk), .A(IN_DATA[7:0]), .C(SB_DATA_W[7:0]));
  
  always @(*) begin
        SB_DATA = SB_DATA_W;
    end

endmodule